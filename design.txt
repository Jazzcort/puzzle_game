  At the beginning of crafting this final project, I started with creating those three main frames in the game window. After that, I created Puzzle class which acts like a set of puzzle. I can load a different puzzle by creating another Puzzle class to replace the previous Puzzle class. At first, I thought I can use just Turtle class to act like puzzle pieces, but after I considered it more in details, I realized that I also have to attach a few more information with each piece like its area, position, piece number... etc. So, I created another class, Pieces. This class can do the switching behavior in the game window with other same classes. The design of switching behavior was the most difficult part in this project for me, because there were so many things to take care of when we switch two pieces like switching the position of two pieces in Puzzle().puz, and updating the range of area and the position of two pieces. After I completed the switching behavior, I created two more class Button and Leaderboard. Button class was used to create those three buttons. Leaderboard class is a class to update, load, and print the leaderboard.txt.

  In order to operate the game, I created Game class to connect and organize all the classes I had written so far. In addition, I also wrote some important functions in this class. For example, check_win() checks if the player wins, buttons_click() checks which button the player clicks on, and effective_click() checks if the player clicks on the adjacent pieces to the blank piece.

  After finishing all the game behaviors, I started to work on the bonus part. I found the theory that can check if the puzzle is solvable from a website(I'll provide the link at the bottom). Then, I created a function solvable_case() in Puzzle(). This function will shuffle the puzzle pieces and check if it's solvable. If not, it will shuffle the puzzle pieces again until it finds a solvable case. So, it can guarantee that the player always gets a solvable puzzle. In addition, this function will print the sequence and its status of solvability every time it shuffles the sequence. For the part (c) and (d), I modified Puzzle().solvable_case() into a different version which would be easier to be tested with unittest. The explanation in details would be provided in solvable_case.py. ("Test_solvable_case_tester.py" is for part(c) and "Test_solvable_case.py is for (d)")

  Last but not least, I want to point out some different behaviors in my puzzle game against the demonstration video. First, my error message for leaderboard not found doesn't show up before the pop-up window for player's name input. It shows up after all the puzzle pieces are created. Second, my mechanism to check if the player loses the game is different than what has been shown in the video. In the video, if the maximum step is 5, after the player moves 5 steps and the puzzle is not solved, he is not considered losing the game. Only if the player moves the 6th step, then he is considered losing the game. However, in my puzzle game, if the player's moves is equal to the maximum moves and the puzzle is not solved, he will be considered losing the game. Third, the location of the puzzle pieces is related to its picture size. Therefore, the puzzle pieces of fifteen.puz will not spread out as wide as what was shown in the video. Last, my LeaderBoard class will create a "leaderboard.txt" when someone wins the game if there is no "leaderboard.txt" in the game package.

Link :https://www.geeksforgeeks.org/check-instance-15-puzzle-solvable/

